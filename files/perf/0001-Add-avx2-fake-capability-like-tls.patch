From 27f98ebb994f9af865f1d5c790ff53c2648bccfc Mon Sep 17 00:00:00 2001
From: Dimitri John Ledkov <dimitri.j.ledkov@intel.com>
Date: Thu, 8 Jan 2015 13:24:30 +0000
Subject: [PATCH] Add avx2 fake-capability, like tls.
Organization: Intel Corporation (UK) Ltd. - Co. Reg. #1134945 - Pipers Way, Swindon SN3 1RJ

Currently numbered as fore last from tls, in the extra dso capabilities.

Other extra capabilities reservations:
0 - used to be abused by broken glibc
1 - nosegneg (XEN fake capability)
10 (fore-last) - avx2, this project specific capability
11 (last) - tls
---
 elf/dl-cache.c  |  3 ++-
 elf/dl-hwcaps.c | 45 +++++++++++++++++++++++++++++++++++++++++++++
 elf/ldconfig.c  |  1 +
 3 files changed, 48 insertions(+), 1 deletion(-)

Index: glibc-2.21/elf/dl-cache.c
===================================================================
--- glibc-2.21.orig/elf/dl-cache.c
+++ glibc-2.21/elf/dl-cache.c
@@ -259,8 +259,9 @@ _dl_load_cache_lookup (const char *name)
 	platform = 1ULL << platform;
 
 #define _DL_HWCAP_TLS_MASK (1LL << 63)
+#define _DL_HWCAP_AVX2_MASK (1LL << 62)
       uint64_t hwcap_exclude = ~((GLRO(dl_hwcap) & GLRO(dl_hwcap_mask))
-				 | _DL_HWCAP_PLATFORM | _DL_HWCAP_TLS_MASK);
+				 | _DL_HWCAP_PLATFORM | _DL_HWCAP_TLS_MASK | _DL_HWCAP_AVX2_MASK);
 
       /* Only accept hwcap if it's for the right platform.  */
 #define HWCAP_CHECK \
@@ -271,6 +272,9 @@ _dl_load_cache_lookup (const char *name)
       if (_DL_PLATFORMS_COUNT						      \
 	  && (lib->hwcap & _DL_HWCAP_PLATFORM) != 0			      \
 	  && (lib->hwcap & _DL_HWCAP_PLATFORM) != platform)		      \
+	continue; \
+      if (!_avx2_available() &&			\
+	    (lib->hwcap & _DL_HWCAP_AVX2_MASK)) \
 	continue
       SEARCH_CACHE (cache_new);
     }
Index: glibc-2.21/elf/dl-hwcaps.c
===================================================================
--- glibc-2.21.orig/elf/dl-hwcaps.c
+++ glibc-2.21/elf/dl-hwcaps.c
@@ -31,6 +31,72 @@
 # define _DL_FIRST_EXTRA _DL_HWCAP_COUNT
 #endif
 
+#ifdef __x86_64__
+#include <cpuid.h>
+#define XCR_XFEATURE_ENABLED_MASK 0x0
+#define XSTATE_FP  0x1
+#define XSTATE_SSE 0x2
+#define XSTATE_YMM 0x4
+#endif
+internal_function
+int _avx2_available(void)
+{
+
+/* Ideally this should simply be __builtin_cpu_supports("avx2") */
+/* However that does not check for OSXSAVE, XSTATE_SSE, XSTATE_YMM */
+/* Origin gcc/testsuite/gcc.target/i386/avx2-check.h */
+/* Origin gcc/testsuite/gcc.target/i386/avx-os-support.h */
+#ifdef __x86_64__
+  unsigned int eax, ebx, ecx, edx;
+
+  if (__get_cpuid (1, &eax, &ebx, &ecx, &edx)) {
+    if (__glibc_unlikely (GLRO(dl_debug_mask) & DL_DEBUG_LIBS))
+      _dl_debug_printf ("  got cpuid\n");
+  } else {
+    if (__glibc_unlikely (GLRO(dl_debug_mask) & DL_DEBUG_LIBS))
+      _dl_debug_printf ("  failed to get cpuid\n");
+    return 0;
+  }
+
+  if ((ecx & bit_OSXSAVE) == (bit_OSXSAVE))
+  {
+    if (__glibc_unlikely (GLRO(dl_debug_mask) & DL_DEBUG_LIBS))
+      _dl_debug_printf ("  have OSXSAVE support\n");
+
+    if (__get_cpuid_max (0, NULL) < 7) {
+      if (__glibc_unlikely (GLRO(dl_debug_mask) & DL_DEBUG_LIBS))
+	_dl_debug_printf ("  cpuid_max less than 7\n");
+      return 0;
+    }
+
+    __cpuid_count (7, 0, eax, ebx, ecx, edx);
+
+    if ((ebx & bit_AVX2) != bit_AVX2) {
+      if (__glibc_unlikely (GLRO(dl_debug_mask) & DL_DEBUG_LIBS))
+	_dl_debug_printf ("  AVX2 bit not set\n");
+      return 0;
+    }
+    if (__glibc_unlikely (GLRO(dl_debug_mask) & DL_DEBUG_LIBS))
+      _dl_debug_printf ("  AVX2 bit is set\n");
+
+    ecx = XCR_XFEATURE_ENABLED_MASK;
+    __asm__ ("xgetbv" : "=a" (eax), "=d" (edx) : "c" (ecx));
+    if ((eax & (XSTATE_SSE | XSTATE_YMM)) == (XSTATE_SSE | XSTATE_YMM)) {
+      if (__glibc_unlikely (GLRO(dl_debug_mask) & DL_DEBUG_LIBS)) {
+	_dl_debug_printf ("  have sse/ymm support\n");
+	_dl_debug_printf ("  AVX2 support enabled\n");
+      }
+      return 1;
+    } else {
+      if (__glibc_unlikely (GLRO(dl_debug_mask) & DL_DEBUG_LIBS))
+	_dl_debug_printf ("  do not have sse/ymm support\n");
+      return 0;
+    }
+  }
+#endif
+  return 0;
+}
+
 /* Return an array of useful/necessary hardware capability names.  */
 const struct r_strlenpair *
 internal_function
@@ -111,6 +177,9 @@ _dl_important_hwcaps (const char *platfo
   /* For TLS enabled builds always add 'tls'.  */
   ++cnt;
 
+  /* Add 'avx2' capability on x86_64 */
+  ++cnt;
+
   /* Create temporary data structure to generate result table.  */
   struct r_strlenpair temp[cnt];
   m = 0;
@@ -163,6 +232,20 @@ _dl_important_hwcaps (const char *platfo
   temp[m].len = 3;
   ++m;
 
+  if (_avx2_available())
+    {
+      if (__glibc_unlikely (GLRO(dl_debug_mask) & DL_DEBUG_LIBS))
+	_dl_debug_printf ("  adding avx2 cap support\n");
+      temp[m].str = "avx2";
+      temp[m].len = 4;
+      ++m;
+    }
+  else {
+    if (__glibc_unlikely (GLRO(dl_debug_mask) & DL_DEBUG_LIBS))
+      _dl_debug_printf ("  not adding avx2 cap support\n");
+    --cnt;
+  }
+
   assert (m == cnt);
 
   /* Determine the total size of all strings together.  */
Index: glibc-2.21/elf/ldconfig.c
===================================================================
--- glibc-2.21.orig/elf/ldconfig.c
+++ glibc-2.21/elf/ldconfig.c
@@ -1297,6 +1297,7 @@ main (int argc, char **argv)
      under which TLS support was optional.  The entry is no longer needed, but
      must remain for compatibility.  */
   hwcap_extra[63 - _DL_FIRST_EXTRA] = "tls";
+  hwcap_extra[62 - _DL_FIRST_EXTRA] = "avx2";
 
   set_hwcap ();
 
Index: glibc-2.21/sysdeps/generic/ldsodefs.h
===================================================================
--- glibc-2.21.orig/sysdeps/generic/ldsodefs.h
+++ glibc-2.21/sysdeps/generic/ldsodefs.h
@@ -904,6 +904,9 @@ extern const struct r_strlenpair *_dl_im
 							size_t *max_capstrlen)
      internal_function;
 
+extern int _avx2_available(void)
+     internal_function;
+
 /* Look up NAME in ld.so.cache and return the file name stored there,
    or null if none is found.  Caller must free returned string.  */
 extern char *_dl_load_cache_lookup (const char *name)
